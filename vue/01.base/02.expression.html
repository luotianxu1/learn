<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <div id="app">
            <!--  当前这个表达式 最后会被编译成函数  _xxx(msg === 'hello'? true:false) -->
            {{ 1+ 1 }}
            <!-- 不能放js 语法 因为最终会将返回值 传递给函数 -->
            {{msg === 'hello'? true:false}}
            <!-- 函数返回结果 -->
            {{msg.b}} {{arr}}
        </div>
        <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
        <script>
            let vm = new Vue({
                el: '#app',
                data() {
                    return {
                        // 会递归的去循环vue中的属性 （浪费性能的地方） 会给每个属性都增加getter和setter， 当属性变化时会更新视图
                        // 重写了数组中的方法，当调用数组方法时会触发更新,也会对数组中的每一项进行了监控

                        // 对象只监控了默认自带的属性,新增属性是不生效的
                        // 数组 数组的索引放生变化 或者 数组的长度放生变化 不会触发实体更新的
                        // 会监控数组中的引用类型的
                        msg: {
                            a: 1,
                        },
                        arr: [1, 2, { a: 1 }],
                    }
                },
            })
            vm.$set(vm.arr, 0, 100) // 内部采用的就是splice方法
            // vm.$delete(vm.arr,0);
            // vue2 中的缺陷 vue3.0中通过proxy 进行了结果
            vm.arr[2].a = 100

            // 如何用proxy 来实现响应式原理
            let obj = {
                name: {
                    name: 'jw',
                },
                arr: ['吃', '喝', '玩'],
            }
            // 兼容性差  可以代理13种方法 set get
            // defineProperty他只能对特定的属性 进行拦截
            let handler = {
                // target 就是原对象 key就是当前取的是哪个值
                get(target, key) {
                    // console.log('收集依赖');
                    if (
                        typeof target[key] === 'object' &&
                        target[key] !== null
                    ) {
                        // 递归代理 只有取到对应值的时候 才会进行代理
                        return new Proxy(target[key], handler)
                    }
                    // Reflect 反射 这个方法里包含了很多的api
                    return Reflect.get(target, key) // target[key]
                },
                // 知道这个机制 先更改索引 在更新长度
                set(target, key, value) {
                    // [1,2,3].length = 4;
                    // 判断一下 当前是新增操作还是修改操作
                    let oldValue = target[key] // [1,2,3,123]
                    if (!oldValue) {
                        console.log('新增属性')
                    } else if (oldValue !== value) {
                        console.log('修改属性')
                    }
                    // target[key] = value; // 设置时 如果设置不成功，设置不成功不会报错，对象不可配置
                    return Reflect.set(target, key, value)
                },
            }
            let proxy = new Proxy(obj, handler)
            // 懒代理
            // proxy.name.name  = 123;
            proxy.arr[0] = 100
            proxy.xxx = 100
            console.log(obj)
        </script>
    </body>
</html>
